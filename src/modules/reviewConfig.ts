import { getPref, setPref } from "../utils/prefs";
import {
  AwesomeGPTDetection,
  ReviewAPIConfigMode,
  ReviewProvider,
  ReviewSettings,
  ZoteroGPTPrefsSnapshot,
} from "./reviewTypes";

const DEFAULTS: ReviewSettings = {
  modelConfigMode: "custom",
  apiConfigMode: "zoterogpt",
  provider: "openai",
  api: "https://api.openai.com",
  secretKey: "",
  model: "gpt-3.5-turbo",
  temperature: 1.0,
  embeddingModel: "text-embedding-ada-002",
  embeddingBatchNum: 10,
  timeoutSeconds: 600,
  dailyLimit: 100,
  usePDFAsInputSource: true,
  usePDFAnnotationsAsContext: true,
  importPDFAnnotationsAsField: true,
  enablePDFInputTruncation: false,
  pdfTextMaxChars: 20_000,
  pdfAnnotationTextMaxChars: 12_000,
  customPromptTemplate: "",
  customFolderSummaryPromptTemplate: "",
};

export function getReviewSettings(): ReviewSettings {
  return {
    modelConfigMode: "custom",
    apiConfigMode: "zoterogpt",
    // Keep API behavior aligned with Zotero GPT.
    provider: "openai",
    api: normalizeAPIBase(
      String(getPref("api") || getPref("apiBaseURL") || DEFAULTS.api).trim(),
    ),
    secretKey: String(getPref("secretKey") || getPref("apiKey") || "").trim(),
    model: String(getPref("model") || DEFAULTS.model).trim(),
    temperature: normalizeFloat(
      getPref("temperature"),
      DEFAULTS.temperature,
      0,
      1,
    ),
    embeddingModel: DEFAULTS.embeddingModel,
    embeddingBatchNum: Math.max(
      1,
      normalizeInt(getPref("embeddingBatchNum"), DEFAULTS.embeddingBatchNum),
    ),
    timeoutSeconds: Math.max(
      DEFAULTS.timeoutSeconds,
      normalizeInt(getPref("timeoutSeconds"), DEFAULTS.timeoutSeconds),
    ),
    dailyLimit: normalizeInt(getPref("dailyLimit"), DEFAULTS.dailyLimit),
    usePDFAsInputSource: normalizeBool(
      getPref("usePDFAsInputSource"),
      DEFAULTS.usePDFAsInputSource,
    ),
    usePDFAnnotationsAsContext: normalizeBool(
      getPref("usePDFAnnotationsAsContext"),
      DEFAULTS.usePDFAnnotationsAsContext,
    ),
    importPDFAnnotationsAsField: normalizeBool(
      getPref("importPDFAnnotationsAsField"),
      DEFAULTS.importPDFAnnotationsAsField,
    ),
    enablePDFInputTruncation: normalizeBool(
      getPref("enablePDFInputTruncation"),
      DEFAULTS.enablePDFInputTruncation,
    ),
    pdfTextMaxChars: Math.max(
      1,
      normalizeInt(getPref("pdfTextMaxChars"), DEFAULTS.pdfTextMaxChars),
    ),
    pdfAnnotationTextMaxChars: Math.max(
      1,
      normalizeInt(
        getPref("pdfAnnotationTextMaxChars"),
        DEFAULTS.pdfAnnotationTextMaxChars,
      ),
    ),
    customPromptTemplate: String(
      getPref("customPromptTemplate") || DEFAULTS.customPromptTemplate,
    ).trim(),
    customFolderSummaryPromptTemplate: String(
      getPref("customFolderSummaryPromptTemplate") ||
        DEFAULTS.customFolderSummaryPromptTemplate,
    ).trim(),
  };
}

export function saveReviewSettings(input: Partial<ReviewSettings>) {
  const current = getReviewSettings();
  const next = {
    ...current,
    ...input,
    modelConfigMode: "custom" as const,
    apiConfigMode: "zoterogpt" as ReviewAPIConfigMode,
    // Keep API behavior aligned with Zotero GPT.
    provider: "openai" as ReviewProvider,
    embeddingModel: DEFAULTS.embeddingModel,
    temperature: normalizeFloat(input.temperature, current.temperature, 0, 1),
  };
  setPref("modelConfigMode", next.modelConfigMode);
  setPref("apiConfigMode", next.apiConfigMode);
  setPref("provider", next.provider);
  setPref("api", normalizeAPIBase(next.api));
  setPref("secretKey", next.secretKey);
  setPref("embeddingModel", DEFAULTS.embeddingModel);
  setPref("embeddingBatchNum", next.embeddingBatchNum);
  // Legacy aliases kept in sync for backward compatibility with older Exitem builds.
  setPref("apiBaseURL", normalizeAPIBase(next.api));
  setPref("apiKey", next.secretKey);
  setPref("model", next.model);
  setPref(
    "temperature",
    normalizeFloat(next.temperature, DEFAULTS.temperature, 0, 1),
  );
  setPref("timeoutSeconds", next.timeoutSeconds);
  setPref("dailyLimit", next.dailyLimit);
  setPref("usePDFAsInputSource", Boolean(next.usePDFAsInputSource));
  setPref(
    "usePDFAnnotationsAsContext",
    Boolean(next.usePDFAnnotationsAsContext),
  );
  setPref(
    "importPDFAnnotationsAsField",
    Boolean(next.importPDFAnnotationsAsField),
  );
  setPref("enablePDFInputTruncation", Boolean(next.enablePDFInputTruncation));
  setPref(
    "pdfTextMaxChars",
    Math.max(1, normalizeInt(next.pdfTextMaxChars, 20_000)),
  );
  setPref(
    "pdfAnnotationTextMaxChars",
    Math.max(1, normalizeInt(next.pdfAnnotationTextMaxChars, 12_000)),
  );
  setPref("customPromptTemplate", next.customPromptTemplate);
  setPref(
    "customFolderSummaryPromptTemplate",
    next.customFolderSummaryPromptTemplate,
  );
  return next;
}

export function getZoteroGPTPrefsSnapshot(): ZoteroGPTPrefsSnapshot | null {
  try {
    const base = "extensions.zotero.zoterogpt";
    const prefs = (Zotero as any)?.Prefs;
    if (!prefs?.get) return null;

    const api = normalizeAPIBase(String(prefs.get(`${base}.api`) || "").trim());
    const secretKey = String(prefs.get(`${base}.secretKey`) || "").trim();
    const model = String(prefs.get(`${base}.model`) || "").trim();
    const temperature = normalizeFloat(
      prefs.get(`${base}.temperature`),
      1.0,
      0,
      1,
    );
    const embeddingBatchNum = Math.max(
      1,
      normalizeInt(
        prefs.get(`${base}.embeddingBatchNum`),
        DEFAULTS.embeddingBatchNum,
      ),
    );

    // zotero-gpt currently hard-codes this model in Meet/OpenAI.ts
    const embeddingModel = "text-embedding-ada-002";

    if (!api && !secretKey && !model) return null;
    return {
      api: api || DEFAULTS.api,
      secretKey,
      model: model || DEFAULTS.model,
      temperature,
      embeddingModel,
      embeddingBatchNum,
      source: "zoterogpt",
    };
  } catch {
    return null;
  }
}

export function getEffectiveReviewAPISettings(settings = getReviewSettings()) {
  const snapshot = getZoteroGPTPrefsSnapshot();
  if (snapshot) {
    return {
      ...settings,
      apiConfigMode: "zoterogpt" as const,
      provider: "openai" as ReviewProvider,
      api: snapshot.api,
      secretKey: snapshot.secretKey,
      model: snapshot.model,
      temperature: snapshot.temperature,
      embeddingModel: snapshot.embeddingModel,
      embeddingBatchNum: snapshot.embeddingBatchNum,
    };
  }
  return {
    ...settings,
    apiConfigMode: "zoterogpt" as const,
    provider: "openai" as ReviewProvider,
    secretKey: "",
    model: "",
    embeddingModel: "text-embedding-ada-002",
  };
}

export function detectAwesomeGPT(): AwesomeGPTDetection {
  const mainWin = getPrimaryMainWindowSafe();
  const zoteroGPT = (Zotero as any)?.ZoteroGPT;
  const meet = (mainWin as any)?.Meet || (globalThis as any)?.window?.Meet;
  if (zoteroGPT || meet) {
    const meetCallable = typeof meet?.OpenAI?.getGPTResponse === "function";
    const viewsReady = Boolean(zoteroGPT?.views);
    return {
      installed: true,
      source: "Zotero.ZoteroGPT / window.Meet",
      addonName: "Zotero GPT",
      callable: meetCallable && viewsReady,
      detail: [
        zoteroGPT ? "检测到 Zotero.ZoteroGPT" : "",
        meet ? "检测到 window.Meet" : "",
        viewsReady ? "views 已初始化" : "views 未初始化",
      ]
        .filter(Boolean)
        .join("，"),
      obstacle:
        meetCallable && viewsReady
          ? "当前通过 zotero-gpt 的内部 Meet API 兼容桥接，接口可能随版本变化。"
          : "zotero-gpt 已安装，但其内部 API 尚未完全就绪（可能需要其界面先初始化）。",
    };
  }

  const candidates: Array<[string, any]> = [
    ["Zotero.AwesomeGPT", (Zotero as any)?.AwesomeGPT],
    ["Zotero.GPT", (Zotero as any)?.GPT],
    ["window.AwesomeGPT", (globalThis as any)?.AwesomeGPT],
    ["window.awesomeGPT", (globalThis as any)?.awesomeGPT],
  ];

  for (const [source, value] of candidates) {
    if (value) {
      return {
        installed: true,
        source,
        addonName: "Awesome GPT",
        callable: true,
        detail:
          typeof value === "object"
            ? Object.keys(value).join(", ")
            : typeof value,
      };
    }
  }

  // Best-effort add-on manager detection (may be unavailable in some contexts)
  try {
    const maybeAddonManager = (globalThis as any).AddonManager;
    if (maybeAddonManager?.getAddonByID) {
      return {
        installed: false,
        source: "AddonManager",
        callable: false,
        detail: "可访问插件管理器，但未发现可直接调用接口",
        obstacle: "兼容 GPT 插件未必对外暴露全局 API，自动调用可能受限",
      };
    }
  } catch {
    // ignore
  }

  return {
    installed: false,
    source: "not-found",
    callable: false,
    obstacle:
      "未发现运行时接口；如果 GPT 插件未暴露全局 API，本插件无法直接调用",
  };
}

export async function detectAwesomeGPTAsync(): Promise<AwesomeGPTDetection> {
  const runtime = detectAwesomeGPT();
  if (runtime.callable) {
    return runtime;
  }

  const addonManager = await getAddonManagerSafe();
  if (!addonManager) {
    return {
      ...runtime,
      detail:
        runtime.detail ||
        "当前环境无法访问 AddonManager，无法进一步确认是否已安装兼容 GPT 插件",
    };
  }

  try {
    const addons: any[] = await getAllExtensions(addonManager);
    const match = addons.find((addon) => {
      const name = String(addon?.name || "");
      const id = String(addon?.id || "");
      return /(awesome\s*gpt|zotero\s*gpt|gpt\s+meet\s+zotero)/i.test(
        `${name} ${id}`,
      );
    });

    if (!match) {
      return {
        ...runtime,
        detail: "在已安装扩展列表中未发现兼容 GPT 插件",
      };
    }

    return {
      installed: true,
      source: "AddonManager",
      callable: false,
      addonID: String(match.id || ""),
      addonName: String(match.name || "GPT 插件"),
      detail: `已检测到插件：${String(match.name || "GPT 插件")}`,
      obstacle:
        "已安装但未检测到可调用接口。该插件可能未向其他插件暴露稳定 API，建议优先使用本插件 API 配置。",
    };
  } catch (e: any) {
    return {
      ...runtime,
      detail: `读取已安装插件列表失败：${String(e?.message || e)}`,
      obstacle: "无法通过 AddonManager 确认 GPT 插件安装状态",
    };
  }
}

export function isCustomAIConfigured(settings = getReviewSettings()) {
  const effective = getEffectiveReviewAPISettings(settings);
  return Boolean(effective.secretKey && effective.model);
}

function normalizeInt(value: unknown, fallback: number) {
  const n = Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(1, Math.floor(n));
}

function normalizeBool(value: unknown, fallback: boolean) {
  if (typeof value === "boolean") return value;
  if (typeof value === "number") return value !== 0;
  if (typeof value === "string") {
    const v = value.trim().toLowerCase();
    if (["1", "true", "yes", "on"].includes(v)) return true;
    if (["0", "false", "no", "off"].includes(v)) return false;
  }
  return fallback;
}

function normalizeFloat(
  value: unknown,
  fallback: number,
  min = Number.NEGATIVE_INFINITY,
  max = Number.POSITIVE_INFINITY,
) {
  const n = Number(value);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(min, Math.min(max, n));
}

function normalizeAPIBase(value: string) {
  const text = String(value || "").trim();
  if (!text) return DEFAULTS.api;
  return text.replace(/\/(?:v1)?\/?$/, "");
}

async function getAddonManagerSafe(): Promise<any | null> {
  const globalAddonManager = (globalThis as any).AddonManager;
  if (globalAddonManager) return globalAddonManager;

  try {
    const chromeUtils = (globalThis as any).ChromeUtils;
    if (chromeUtils?.importESModule) {
      const mod = chromeUtils.importESModule(
        "resource://gre/modules/AddonManager.sys.mjs",
      );
      if (mod?.AddonManager) return mod.AddonManager;
    }
  } catch {
    // ignore
  }

  return null;
}

function getPrimaryMainWindowSafe() {
  try {
    return (Zotero.getMainWindows?.()[0] as any) || null;
  } catch {
    return null;
  }
}

async function getAllExtensions(addonManager: any): Promise<any[]> {
  if (typeof addonManager.getAddonsByTypes === "function") {
    return (await addonManager.getAddonsByTypes(["extension"])) || [];
  }
  if (typeof addonManager.getAllAddons === "function") {
    const addons = (await addonManager.getAllAddons()) || [];
    return addons.filter(
      (addon: any) => String(addon?.type || "") === "extension",
    );
  }
  return [];
}
